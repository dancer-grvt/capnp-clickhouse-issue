// Code generated by capnpc-go. DO NOT EDIT.

package sampleSchema

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
)

type TestStruct capnp.Struct

// TestStruct_TypeID is the unique identifier for the type TestStruct.
const TestStruct_TypeID = 0xec440b5c75fb4801

func NewTestStruct(s *capnp.Segment) (TestStruct, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return TestStruct(st), err
}

func NewRootTestStruct(s *capnp.Segment) (TestStruct, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return TestStruct(st), err
}

func ReadRootTestStruct(msg *capnp.Message) (TestStruct, error) {
	root, err := msg.Root()
	return TestStruct(root.Struct()), err
}

func (s TestStruct) String() string {
	str, _ := text.Marshal(0xec440b5c75fb4801, capnp.Struct(s))
	return str
}

func (s TestStruct) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (TestStruct) DecodeFromPtr(p capnp.Ptr) TestStruct {
	return TestStruct(capnp.Struct{}.DecodeFromPtr(p))
}

func (s TestStruct) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s TestStruct) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s TestStruct) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s TestStruct) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s TestStruct) TitleField() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s TestStruct) HasTitleField() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s TestStruct) TitleFieldBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s TestStruct) SetTitleField(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s TestStruct) InnerTuple() (InnerTuple, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return InnerTuple(p.Struct()), err
}

func (s TestStruct) HasInnerTuple() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s TestStruct) SetInnerTuple(v InnerTuple) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewInnerTuple sets the innerTuple field to a newly
// allocated InnerTuple struct, preferring placement in s's segment.
func (s TestStruct) NewInnerTuple() (InnerTuple, error) {
	ss, err := NewInnerTuple(capnp.Struct(s).Segment())
	if err != nil {
		return InnerTuple{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// TestStruct_List is a list of TestStruct.
type TestStruct_List = capnp.StructList[TestStruct]

// NewTestStruct creates a new list of TestStruct.
func NewTestStruct_List(s *capnp.Segment, sz int32) (TestStruct_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[TestStruct](l), err
}

// TestStruct_Future is a wrapper for a TestStruct promised by a client call.
type TestStruct_Future struct{ *capnp.Future }

func (f TestStruct_Future) Struct() (TestStruct, error) {
	p, err := f.Future.Ptr()
	return TestStruct(p.Struct()), err
}
func (p TestStruct_Future) InnerTuple() InnerTuple_Future {
	return InnerTuple_Future{Future: p.Future.Field(1, nil)}
}

type InnerTuple capnp.Struct

// InnerTuple_TypeID is the unique identifier for the type InnerTuple.
const InnerTuple_TypeID = 0xf4ad4e708c5e6974

func NewInnerTuple(s *capnp.Segment) (InnerTuple, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return InnerTuple(st), err
}

func NewRootInnerTuple(s *capnp.Segment) (InnerTuple, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return InnerTuple(st), err
}

func ReadRootInnerTuple(msg *capnp.Message) (InnerTuple, error) {
	root, err := msg.Root()
	return InnerTuple(root.Struct()), err
}

func (s InnerTuple) String() string {
	str, _ := text.Marshal(0xf4ad4e708c5e6974, capnp.Struct(s))
	return str
}

func (s InnerTuple) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (InnerTuple) DecodeFromPtr(p capnp.Ptr) InnerTuple {
	return InnerTuple(capnp.Struct{}.DecodeFromPtr(p))
}

func (s InnerTuple) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s InnerTuple) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s InnerTuple) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s InnerTuple) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s InnerTuple) NormalField() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s InnerTuple) HasNormalField() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s InnerTuple) NormalFieldBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s InnerTuple) SetNormalField(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s InnerTuple) NormalField2() int32 {
	return int32(capnp.Struct(s).Uint32(0))
}

func (s InnerTuple) SetNormalField2(v int32) {
	capnp.Struct(s).SetUint32(0, uint32(v))
}

func (s InnerTuple) SpecialField() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s InnerTuple) HasSpecialField() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s InnerTuple) SetSpecialField(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

// InnerTuple_List is a list of InnerTuple.
type InnerTuple_List = capnp.StructList[InnerTuple]

// NewInnerTuple creates a new list of InnerTuple.
func NewInnerTuple_List(s *capnp.Segment, sz int32) (InnerTuple_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[InnerTuple](l), err
}

// InnerTuple_Future is a wrapper for a InnerTuple promised by a client call.
type InnerTuple_Future struct{ *capnp.Future }

func (f InnerTuple_Future) Struct() (InnerTuple, error) {
	p, err := f.Future.Ptr()
	return InnerTuple(p.Struct()), err
}

const schema_b44039789e9fa5cd = "x\xda\x84\xce\xbdJ3A\x18\xc5\xf1sf6o^" +
	"0!Y\x12\xd0&\xbd\x16~Dm\x14\x8b\x10bP" +
	"P\xc9\x90\x08\"\"\xae\x9b\x01Wf7k\xb2\x8b^" +
	"\x84\xd7\xa0\x95vb\xe3mx'6\x82\x9d\xc8\xca\x88" +
	"F\xb1\xb1{\xf8s\x1e\xf8\x95o\x1bN\xbd8) " +
	"\xd4T\xee_\xc6\x8d\xd7\xf4`\xa2\xf5\x04\xb7\xc6\xec\xf1" +
	"\xe6\xfa\xeab\xa5\xf1\x80\x9c\xc8\x03\xf5\xe7&+d\x1e" +
	"p\xdf\xce\xc1,\x09\x0e/\xe3\x9d\xbb\x17\xa8\x1a\x7fo" +
	"\x97<6Y9\xb3\xe3J\xc8{\xccf#/\x8c\x8d" +
	"\xee\xfa\xce\x89\x0e\xbd\xf9\x81\xe9w}{\xcd\xf9^\x1c" +
	"\xc5\xab==J\xba\xc90\xf5\x13tH\xf5_:\x80" +
	"C\xc0\x9d\xd9\x07\xd4\xb4\xa4Z\x16t\xc9*m\xac\xdb" +
	"\xb8 \xa9\xd6\x84e$F\xb7\x03\x0di\xfa,@\xb0" +
	"\x00fA\x14\xe9a/\x8d!\x8df\xf9\x9b\x0a\xb2\x0c" +
	"\xfe\x81\xd9\xfc|6\xfa\x03S\x18c\xd6\x8f\x01\xd5\x92" +
	"T\x1d\xc1/\xcb\xf6)\xa0\xb6$\xd5\x9e\xa0+X\xa5" +
	"\x00\xdc]\x1b{\x92\xeaH0\x8b\x06\xc3\xd03\xed\x00" +
	"y\xfdC8\xae%m\xfa\x8bt \xe8XY\xac\xfd" +
	"\xc03m\x94\x02\xbb.B\xb0\x08\xbe\x07\x00\x00\xff\xff" +
	"\x0f\x0fh\xdf"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_b44039789e9fa5cd,
		Nodes: []uint64{
			0xec440b5c75fb4801,
			0xf4ad4e708c5e6974,
		},
		Compressed: true,
	})
}
